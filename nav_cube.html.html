<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>WebGL navigation POC</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace, monospace;
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>


<script src="js_lib/three.min.js"></script>
<script src="js_lib/stats.min.js"></script>
<script src="js_lib/detector.js"></script>

<script>
    var container, stats;

    var camera, scene, projector, renderer;
    var cube;

    var targetRotation = 0;
    var targetRotationOnMouseDown = 0;

    var mouseX = 0;
    var mouseXOnMouseDown = 0;
    var clientClickX = 0;
    var clientClickY = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    init();
    animate();

    function init() {
        container = document.createElement('div');
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(38, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.y = 450;
        camera.position.x = 330;
        camera.position.z = 350;
        camera.rotation.x = -0.75;
        camera.rotation.y = 0.60;
        camera.rotation.z = 0.477;

        scene = new THREE.Scene();
        scene.add(new THREE.AmbientLight(0xe0e0e0));

        if (Detector.webgl) {
            renderer = new THREE.WebGLRenderer({antialias: true});
            // If its not supported, instantiate the canvas renderer to support all non WebGL browsers
        } else {
            renderer = new THREE.CanvasRenderer();
        }

        projector = new THREE.Projector();
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild(stats.domElement);

        // Cube
        var materialsC = [];
        materialsC.push(new THREE.MeshLambertMaterial({
            color: 0xffffff,
            map: THREE.ImageUtils.loadTexture('textures/r.jpg'),
            transparent: false
        }));
        materialsC.push(new THREE.MeshLambertMaterial({
            color: 0xffffff,
            map: THREE.ImageUtils.loadTexture('textures/l.jpg'),
            transparent: false
        }));
        materialsC.push(new THREE.MeshLambertMaterial({
            color: 0xffffff,
            map: THREE.ImageUtils.loadTexture('textures/u.jpg'),
            transparent: false
        }));
        materialsC.push(new THREE.MeshLambertMaterial({
            color: 0xffffff,
            transparent: false
        }));
        materialsC.push(new THREE.MeshLambertMaterial({
            color: 0xffffff,
            map: THREE.ImageUtils.loadTexture('textures/f.jpg'),
            transparent: false
        }));
        materialsC.push(new THREE.MeshLambertMaterial({
            color: 0xffffff,
            map: THREE.ImageUtils.loadTexture('textures/b.jpg'),
            transparent: false
        }));

        var cubeMaterial = new THREE.MeshFaceMaterial(materialsC);

        cube = new THREE.Mesh(new THREE.CubeGeometry(200, 200, 200, 6, 6, 6), cubeMaterial);

        cube.position.y = 150;
        cube.rotation.y = 0.4;
        scene.add(cube);

        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('touchstart', onDocumentTouchStart, false);
        document.addEventListener('touchmove', onDocumentTouchMove, false);
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDocumentMouseDown(event) {
        event.preventDefault();

        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
        document.addEventListener('mouseout', onDocumentMouseOut, false);

        mouseXOnMouseDown = event.clientX - windowHalfX;
        clientClickX = event.clientX;
        clientClickY = event.clientY;
        targetRotationOnMouseDown = targetRotation;
    }


    function onDocumentMouseMove(event) {
        mouseX = event.clientX - windowHalfX;
        targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.005;
    }


    function onDocumentMouseUp() {
        var x = event.clientX;
        var y = event.clientY;
        if (x === clientClickX && y === clientClickY) {

            var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
            projector.unprojectVector(vector, camera);

            var ray = new THREE.Ray(camera.position, vector.subSelf(camera.position).normalize());
            var intersects = ray.intersectObject(cube);

            if (intersects.length > 0) {

                //console.log('object x:' + intersects[0].face.normal.x +
                //'; y:'+intersects[0].face.normal.y +
                //'; z:'+intersects[0].face.normal.z);
                if (intersects[0].face.normal.x === 0 && intersects[0].face.normal.y === 0 &&
                    intersects[0].face.normal.z === -1) {alert("B face click registered");
                }
                if (intersects[0].face.normal.x === 0 && intersects[0].face.normal.y === 0 &&
                    intersects[0].face.normal.z === 1) {alert("F face click registered");
                }
                if (intersects[0].face.normal.x === 1 && intersects[0].face.normal.y === 0 &&
                    intersects[0].face.normal.z === 0) {alert("R face click registered");
                }
                if (intersects[0].face.normal.x === -1 && intersects[0].face.normal.y === 0 &&
                    intersects[0].face.normal.z === 0) {alert("L face click registered");
                }
                if (intersects[0].face.normal.x === 0 && intersects[0].face.normal.y === 1 &&
                    intersects[0].face.normal.z === 0) {alert("U face click registered");
                }
            }
        }

        document.removeEventListener('mousemove', onDocumentMouseMove, false);
        document.removeEventListener('mouseup', onDocumentMouseUp, false);
        document.removeEventListener('mouseout', onDocumentMouseOut, false);
    }

    function onDocumentMouseOut() {
        document.removeEventListener('mousemove', onDocumentMouseMove, false);
        document.removeEventListener('mouseup', onDocumentMouseUp, false);
        document.removeEventListener('mouseout', onDocumentMouseOut, false);
    }

    function onDocumentTouchStart(event) {
        if (event.touches.length === 1) {
            event.preventDefault();

            mouseXOnMouseDown = event.touches[0].pageX - windowHalfX;
            targetRotationOnMouseDown = targetRotation;
        }
    }

    function onDocumentTouchMove(event) {
        if (event.touches.length === 1) {
            event.preventDefault();
            mouseX = event.touches[0].pageX - windowHalfX;
            targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.15;
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        //console.log(cube.rotation.y);

        cube.rotation.y += (targetRotation - cube.rotation.y) * 0.03;
        renderer.render(scene, camera);
        render();
        stats.update();
    }

    function render() {
    }

</script>
<div>
    <canvas width="300" height="150"></canvas>
</div>


</body>
</html>
